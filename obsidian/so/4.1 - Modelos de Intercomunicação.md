
## Comunicação entre Processos

- Até agora trabalhámos em ambientes multitarefa em que este dá-nos uma vantagem de basear-se em memória partilhada que permite que o estado seja partilhado entre tarefas.
- Com isto vamos partir para algo mais genérico de processos a cooperarem entre si.

> [!NOTE] O que muda do ambiente multitarefa?
> Aqui temos espaços de endereçamento mais disjuntos e isolados uns dos outros.

- Aqui os processos podem comunicar na mesma máquina ou através de redes.

> [!TIP] A comunicação entre processos pode realizar-se em três âmbitos:
> 
> - Uma ==única aplicação==: um processo que executa a interface cliente comunica com o servidor que gere a base de dados.
> - Entre ==aplicações da mesma máquina==: uma aplicação comunica com o servidor de impressão (_spooler_).
> - Enter ==máquinas ligadas por uma rede de dados==: um telemóvel interacta com servidores de um motor de pesquisa.
> 
> 

### Troca de informação entre dois processos

- Muito parecido com produtores-consumidores.

![[Pasted image 20230102161759.png]]

- Temos aqui um produtor (dá informação) e um consumidor que pretendem enviar uma mensagem.
- Sempre que um proocesso pretende enviar uma mensagem precisa de um canal de comuniação.
- O canal pode ter diferentes implementações.

### Canal de Comunicação

- ==Ficheiros== - solução mais simples mas __lenta__. Usada em sistemas de informação.

- ==Memória Partilhada== - precisa de mecanismos para mapear uma região da memória física em dois processos ultrapassando o isolamento de espaços de endereçamento.

- ==Sistema Operativo== - precisa de um objeto para onde copiar a informação da mensgem e permita aos processos consumidor receberem-no.

- ==Redes==

### Arquitetura da Comunicação: Memória Partilhada

- Temos dois espaços de endereçamento disjuntos e temos que criar uma zona de memória partilhada entre esses dois espaços.
- Esse espaço só acontece pedindo ao SO para arranjar essa memória partilhada.

Ler Informação => Receber 
Escrever Informação => Enviar


> [!TIP] Portanto:
> Em multitarefa só declarávamos as variáveis no ambiente e usávamos onde queriamos e aqui temos que declarar nesses espaços específicos.


### Canal: Núcleo do SO

- Temos um produtor e um consumidor com espaços de endereçamento separados e o produtor produziu uma mensagem que quero passar para o outro.
- ___Não se pode passar diretamente___ e ___Não há memória partilhada___, portanto tem que ser feita uma cópia para um núcleo e o outro quando quiser ler pede ao núcleo e será transferida essa informação para o seu espaço de endereçamento.


## Comparação entre os dois usos:

| Memória Partilhada                                     | Objetos do núcleo                                                                                                                |
| ------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| Executa-se em modo utilizador. + rápido.               | Executa-se no núcleo que tem sobrecarga de chamadas. + lento.                                                                    |
| A informação é acedida. Não há acessos extra à memória | A informação é copiada para o núcleo e volta a ser copiada para o espaço do consumidor. Sobrecarga de duas cópias de informação. |
| As funções de enviar e receber são programadas e podem ocorrer erros. Programação + complexa.  | Funções do SO. Programação + fácil. |

## Modelos de Comunicação

> [!NOTE]  Contudo não nos podemos limitar a uma mensagem então quando se quer transmitir + doque 1 mensagem  usamos modelos de comunicação.
> 
> - Um para um.
> - Um para vários.
> - Muitos para um.
> - Um para muitos.

==Muitos-para-um==: O _cliente_ sabe o endereço do _servidor_ e envia-lhe a mensagem. Deve enviar o remetente para obter resposta do servidor.
Não existe ligação entre processos. (___Processo Correio___)

==Um-para-um de muitos==: O _cliente_ pede para ligar-se ao _servidor_ e este decide se bloqueia ou não a ligação.
Quando se ligam criam um canal um-para-um dedicado.
No final desligam o canal.
Estabelece-se uma ligação de processos. (___Telefone___)


## Correio (Canal sem ligação)

- Este canal de comunicação é chamado de _mailbox_ ou _queue_.
- Esta _mailbox_ consegue ___memorizar___ as mensagens quando são mais rapidamente produzidas do que consumidas.
- É aqui que entra os _pipes_.

## Modelo do canal de comunicação

- Tem que ter um nome para ser identificado quando criado.
- Associarem-se. Após isto recebe um _endpoint_.

### Como é que são lidas as mensagens enviadas?

- O sistema não tem nada haver com as mensagens enviadas do produtor para o consumidor.
- Excepto num ponto, se mantém o formato das mensagens ou reune todos os bytes das mensagens e usa como octetos.

### Mensagens Individuais _vs_  Sequência de Octetos

| Mensagens Individuais                                                                  | Sequências de Octetos |
| -------------------------------------------------------------------------------------- | --------------------- |
| se houver _n_ chamadas à função enviar,  tem que haver _n_ mensagens da função receber |  bytes das mensagens são acumulados no canal e as fronteiras esquecidas                     |
| fronteiras são preservadas                                                                                    | chamada da função receber devolve conteúdo de x chamdas a enviar                      |

### Direcionalidade da Comunicação

==Unidirecional==: manda informação apenas num sentido da criação. São necessários então __criar dois canais para enviar e receber__.

==Bidirecional==: o canal pode enviar mensagens nos dois sentidos.


### Resumidamente as Características de um Canal

| Modelo de Comunicação        | 1-para-1, 1-para-muitos, 1-para-umdemuitos, difusão |
| ---------------------------- | --------------------------------------------------- |
| Estrutura de Mensagens       | Individualizadas _bytestream_                       |
| Direcionaliade               | Uni, Bi                                             |
| Estrutura de nomes           | _filenames_, inteiros, TCP/IP                       |
| Modelo de Autorização        | Permissões para enviar/receber                      |
| Capacidades de Armazenamento | -                                                     |

# Unix - IPC

#### Tipos de Ficheiros:

| Tipos               | Descrição                                                |
| ------------------- | -------------------------------------------------------- |
| Normais             | Sequência de octetos (bytes) sem organização em registos |
| Especiais           | periféricos, pipes, FIFOS                                |
| Ficheiros Diretório |  -                                                         |

> [!NOTE] Quando o processo começa a executar arranca três ficheiros:
> - `stdin` - input para o processo (fd - 0)
> - `stdout` - output para o processo (fd - 1)
> - `stderr` - periferico para assinalar erros (fd - 2)
> Um fd é um inteiro para identificar um ficheiro aberto.


## Unix - Pipes

#### Características:
| Modelo de Comunicação | 1-para-1     |
| --------------------- | ------------ |
| Estrutura             | _bytestream_ |
| Direccionalidade      | Uni          |
| Estrutura de nomes    | Nada         |
| Modelo Autorização    | Nada         |
| Capacidade            | Limitada     |
| Funções               | `pipe()`, `read()/write()`, `close()`             |

- Chamamos o sistema, ele cria dois objetos um para leitura e outro para escrita.

> [!EXAMPLE] Para ler e escrever mensagens:
> `ssize_t write(int fds[1], void *buffer, size_t count)`
> `ssize_t read(int fds[0], void *buffer, size_t count)`
> 
> Diferenças a destacar no `write` é que o processo fica bloqueado a escrever num pipe cheio.
> No `read` fica bloqueado a ler um pipe vazio.

- Como é que podemos usar isto? Com uso de ==forks==. 

```c
if(pipe(fds) < 0) {exit(-1);}
if(fork() < 0){
	// lê do pipe no processo filho
	read(fds[0], tmp, sizeof(msg));
	printf("%s\n", tmp);
	exit(0);
} else {
	// escreve no pipe no processo pai
	write(fds[1], msg, sizeof(msg));
	pid_filho = wait();
}
```

- É boa prática fechar o processo que não estou a usar quando entro num ou noutro caso.

# Redireção de Entradas/Saídas

- A função `int dupt(int fd)` duplica um _file_.
- Este novo tem o memso _file pointer_ e o mesmo modo de acesso.
- Ocupa a posição da primeira posição livre da tabela de ficheiros abertos.

### POPEN

- Esta função cria um subprocesso que permite executar um _shell_ num processo filho.

# Names Pipes ou FIFOS

| Modelo de Comunicação | 1-para-1, cliente-servidor |
| --------------------- | -------------------------- |
| Estrutura             | _bytestream_               |
| Direccionalidade      | Uni                        |
| Estrutura de nomes    | Nomes de Files             |
| Modelo Autorização    | Identico aos ficheiros     |
| Capacidade            | Limitada                   |
| Funções               | muitas                     |

#### Como Usar

-   Criação dum named pipe no sistema de ficheiros: `mkfifo`
-   Um processo associa-se a uma extremidade (leitura ou escrita) com a função `open`, bloqueando até que pelo menos 1 processo tenha aberto a outra extremidade;
-   Eliminado dum named pipe do sistema de ficheiros: `unlink`
-   Leitura e envio de informação feitos com API habitual do sistema de ficheiros (`read`, `write`, etc)
-   `read` bloqueia até que alguém escreva no pipe;
-   `write` bloqueia até que alguém leia a mensagem escrita.

> [!EXAMPLE] Exemplo com named
> Código
> ```c
> /* Servidor */
> #include <sys/types.h>
> #include <sys/stat.h>
> #include <fcntl.h>
> 
> #define TAMMSG 1000
> 
> int main() {
>   int fcli, fserv, n;
>   char buf[TAMMSG];
> 
>   /* Garantir que não há nenhum pipe associado a estes paths */
>   unlink("/tmp/servidor");
>   unlink("/tmp/cliente");
> 
>   /* Criação dos pipes */
>   if (mkfifo("/tmp/servidor", 0777) < 0)
>     exit (1);
>   if (mkfifo("/tmp/cliente", 0777) < 0)
>     exit (1);
> 
>   /* Abertura dos pipes */
>   if ((fserv = open("/tmp/servidor", O_RDONLY)) < 0)
> 	exit(1);
>   if ((fcli = open("/tmp/cliente", O_WRONLY)) < 0)
> 	exit(1);
> 
>   for (;;) {
>     n = read(fserv, buf, TAMMSG);
>     if (n <= 0) break;
>     trataPedido(buf);
>     n = write(fcli, buf, TAMMSG);
>   }
> 
>   /* Fechar e desassociar pipes */
>   close(fserv);
>   close(fcli);
>   unlink("/tmp/servidor");
>   unlink("/tmp/cliente");
> 
>   return 0;
> }
> 
> /* ------------------------------------------------------------ */
> 
> /* Cliente */
> #include <sys/types.h>
> #include <sys/stat.h>
> #include <fcntl.h>
> 
> #define TAMMSG 1000
> 
> void produzMsg(char *buf) {
> strcpy(buf, "Mensagem de teste");
> }
> 
> void trataMsg(buf) {
> printf("Recebeu: %s\n", buf);
> }
> 
> int main() {
>   int fcli, fserv;
>   char buf[TAMMSG];
> 
>   /* Os pipes são criados e destruídos pelo servidor */
>   /* Abrir os pipes */
>   if ((fserv = open ("/tmp/servidor", O_WRONLY)) < 0)
> 	exit(1);
>   if ((fcli = open ("/tmp/cliente", O_RDONLY)) < 0)
> 	exit(1);
> 
>   produzMsg(buf);
>   write(fserv, buf, TAMMSG);
>   read(fcli, buf, TAMMSG);
>   trataMsg(buf);
> 
>   /* Fechar os pipes */
>   close(fserv);
>   close(fcli);
> }
> ```

## Signals

> [!TIP] Têm dois diferentes propósitos:
> - Usos tais como CTRL-C.
> - Um processo notificar outro que ocorreu dado evento, tratado de forma assíncrona.

#### Rotinas Assíncronas

- Situações como CTRL-C são tratadas como interurupções no sistema.- `RotinaAssincrona (Evento, Procedimento)`
- Para definir estas rotinas tem de existir uma tabela de eventos.
- Quando existe uma tentativa de usar o PIPE e não existe retorno do outro lado, usamos `sigpipe`.
- 


