Tem que existir cooperação quando estão tarefas a trabalhar em paralelo para sabe o estado de evolução de cada uma.

> [!NOTE] Sincronizar um Evento
> Uma tarefa $i$ quer esperar que outra tarefa $j$ complete uma dada atividade.


### Notificar um Evento

- Já vimos o caso das funções `wait` e `thread_join` quese usavam quando tarefas esperavam pela terminação de outros processos mas precisamos de algo mais genérico pois estas precisam __SEMPRE__ da terminação da atividade.

O que é que pretendemos com esta sincronização mais genérica? Usando um exemplo do mundo real.
Numa loja clientes podem entrar de várias maneiras:

- Entram todos os clientes à espera.
- Entra um só.
- Entram clientes sempre que estão menos de 5 pessoas.

Usamos:
## Semáforos


> [!TIP] Ideia
> É um objeto do SO que tem um contador.

Tem ==__DUAS__== operações:

- __Esperar__: Se o contador for  >  zero então a tarefa prossegue e decrementa o contador senão a tarefa é bloqueada.
- __Assinalar__: Se existir uma tarefa bloqueada coloca-a em execução senão incrementa o contador.

| Propriedades                | Operações        |
| --------------------------- | ---------------- |
| Identificador               | CriarSemáforo    |
| Contador                    | Esperar / wait / down / P          |
| Lista de tarefas bloqueadas | Assinalar / post / signal / up / V | 
| -                           |           EliminarSemáforo       |

A principal diferença entre um _Mutex_ e um _Semáforo_ é que o primeiro apenas pode ter o estado de ABERTO e FECHADO e este pode ter um contador com várias condições.


> [!NOTE] O que acontece realmente?
> Se a tarefa não pode prosseguir é retirada de execução para a fila do semáforo __NÃO EXISTINDO__ espera ativa.

## Operações

```c
s = CriarSemáforo(num_unidade);
```

- Cria um semáforo e inicializa o contador.
- O contador ==define== quantas tarefas vão poder fazer _Esperar_  sem se bloquearem.
- Todas as primitavas se executam atomicamente no núcleo garantindo a exclusão mútua.
- Como é necessário decrementar a variável não existe otimização de executar parte das funções em modo utilizador.

> [!EXAMPLE] Exemplo
>  
> O que está aqui a acontecer quando criamos um semáforo com o valor 0 é que não estamos a dar autorização. Se alguém fizer _esperar_  sobre esse semáforo, bloqueia-se imediatamente.
>  ```c
> CriarSemaforo(SemEvento, 0);
> ```

## Cenários de utilização de um Semáforo

#### Cenário 1

- Tarefa $j$ faz _Esperar_  => Semáforo com o valor 0 bloqueia-se.
- Tarefa $i$ faz _Assinalar_ => Tarefa $j$ é desbloqueada, semáforo permanece com o valor 0.

#### Cenário 2

- Tarefa $i$ faz _Assinalar_  => incrementa o valor do semáforo que fica com o valor 1.
- Tarefa $j$ faz _Esperar_  => Semáforo com o valor 1, decrementa o semáforo e continua, semáforo fica com o valor 0.


> [!TIP] 
> O contador faz com que o semáforo memorize os eventos.
> ```C
> #include <semaphore.h>
> 
> int sem_init(sem_t *sem, int pshared, unsigned value);
> int sem_wait(sem_t *sem);
> int sem_post(sem_t *sem);
> ```
> pshared = 0 semáforo só pode ser usado entre threads do mesmo processo.
> pshared != 0 pode ser usado entre processos independentes.

Uma situação típica de Colaboração é quando diversas tarefas precisam do mesmo recurso finito e quando ele acaba por se esgotar, continuam quando o recurso ficar disponível novamente.

Usando esta notação para o tema dos Semáforos:

- __Inicialização__ => semáforo criado com o número de recursos disponíveis.

- __Alocar um recurso__ => _Esperar_  sobre o semáforo.

- __Libertar um recurso__ => _Assinalar_  um semáforo.


> [!NOTE]
> Se inicializarmos um semáforo a 1 comporta-se como um _mutex_.


## Algoritmo do parque de Estacionamento

> [!EXAMPLE] __Enunciado__:
> 
> O parque tem $N$ Lugares.
> Um cliente entra se tiver lugares livres senão bloqueia-se à espera de lugar.
> Quando sai do parque se tiver clientes à espera tem de acordar um senão incrementa o número de lugares livres.
> 
> __Proposta de Resolução__:
> 
> - Criação de um semáforo `lugaresLivres` inicializado com o número de lugares livres.
> 
> - Cliente (tarefa) que entra no parque executa `wait`.
> Se há lugares livres entra, senão fica bloqueado à espera.
> 
> - Cliente (tarefa) que sai do parque executa `post`.
> Se há clientes à espera liberta um, senão incrementa o semáforo indicando que à mais um lugar livre.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>

#define NUM_LUGARES 5
#define MAX_CLIENTES 10

sem_t lugaresLivres;
pthread_t t_cliente[MAX_CLIENTES];

void entrarNoParque() {
	int val;
	sem_wait(&lugaresLivres);
	sem_getvalue(&lugaresLivres, &val);
	printf ("     => valor do semaforo lugaresLivres %d \n", val );
}

void sairDoParque() {
	sem_post(&lugaresLivres);
}

/* Programa do cliente */
void * procCliente (void *param){
    int i = (int) param;
	int espera;
	entrarNoParque();
	espera = rand() % 10;
	printf ("cliente # %d estacionado. Vai demorar %d seg \n",i, espera);
	sleep (espera);
	sairDoParque();
	printf ("cliente # %d saiu do parque \n",i);
	return 0;
}

int main () {
   int i;
   void * resul;
   time_t t;
   
   /* Inicializa o gerador de números aleatórios  */
   srand((unsigned) time(&t));
   /* Cria e inicializa o semáforo  */
   sem_init(&lugaresLivres, 0, NUM_LUGARES);
      
   /* Cria os clientes  */
   for (i=1; i < MAX_CLIENTES; i++)
   {
	    pthread_create(&t_cliente[i],0, procCliente, (void *) i);
		printf ("criou o cliente numero %d \n",i);
   };
   /* Espera que os clientes terminem  */
   printf ("\n espera terminação dos clientes \n \n");
   for (i=1; i < MAX_CLIENTES; i++) {
		pthread_join(t_cliente[i], &resul);
		printf ("terminou cliente %d  \n", i);
   };    	
   printf ("\n  *parque encerrou* \n");
}
```

O contador em cima usado permite modelar o sistema de gestão de recursos.

## Problema da Barbearia


> [!EXAMPLE] Enunciado:
> Se não existem clientes o barbeiro senta-se e adormece.
> Quando chega um cliente o barbeiro acorda para cortar o cabelo.
> Se chegarem mais clientes enquanto o barbeiro corta o cabelo:
> Se houver cadeiras livres esperam, senão vão embora sem cortar o cabelo.
> 
> __Proposta de Resolução:__
> 
> ==BARBEIRO:==
> - Para resolvermos vai ser necessário o uso de 2 semáforos __porque__ o barbeiro e os clientes têm diferentes modelos de sincronização.
> 
> - O barbeiro só trabalha com a presença de clientes então o semáforo `clientes` vai ser inicializado a 0.
> 
> - Os clientes bloqueiam-se se o barbeiro atender, `barbeiro` inicializado a 1.
> 
> - Se não houver cadeiras vazias saem da barbearia, condição a testar __ANTES__ de bloquear um cliente e que introduz um problema adicional.
>    
>  ==CLIENTES:==
>    
>  - Temos de testar se existem cadeiras vazias então usamos um contador `clientes_espera`. 
>  - Podemos testar isto com o total de cadeiras vazias mais a cadeira do barbeiro para evitar testar se esta última está vazia.      
>  
>  
>  Temos que ter em ==atenção== que este contador é uma variável global que vai trabalhar com váarias tarefas então temos que garantir a secção crítica (_locks_).

```c
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_CADEIRAS 3
#define MAX_CLIENTES 10
#define TRUE 1
#define CORTE 5

static pthread_mutex_t trinco = PTHREAD_MUTEX_INITIALIZER;
int clientes_espera = 0;
void *resul;
pthread_t t_cliente[MAX_CLIENTES], t_barb;
sem_t clientes, barbeiro;

void AtenderCliente(){ 	
	sleep(CORTE);
}

void CortarCabelo(int NCliente){
	printf (" Cliente %d -  a cortar cabelo \n", NCliente);
	sleep(CORTE);
}
/* Programa do Barbeiro*/
void * Procbarbeiro(void *arg) {
    while(TRUE) {
        sem_wait(&clientes);
	AtenderCliente();
 	pthread_mutex_lock(&trinco);
	clientes_espera--;   /* retirar um cliente */
	pthread_mutex_unlock(&trinco);  
        sem_post(&barbeiro); /* desbloquear um cliente */
  }
}

/* Programa dos Clientes */
void * Proccliente(int Ncliente) {
	pthread_mutex_lock(&trinco);
	if (clientes_espera < MAX_CADEIRAS+1) {
	   clientes_espera++;   /* acrescentar um cliente */
	   sem_post(&clientes); /* avisar barbeiro que há clientes */
	   pthread_mutex_unlock(&trinco);
	   sem_wait(&barbeiro);   /* esperar que o barbeiro esteja disponível */
	   CortarCabelo(Ncliente);
	   return 0;
	} else {
   	     pthread_mutex_unlock(&trinco);
	     printf ("barbearia cheia cliente %d \n", Ncliente);
	     return -1;/*desistir se as cadeiras estiverem todas cheias*/
	}
}

int main()
{ 
    /* inicializa os semáforos */
	sem_init(&barbeiro, 0, 1);    
        sem_init(&clientes, 0, 0);
	
	/* Cria o Barbeiro e os Clientes */
	pthread_create (&t_barb, 0, Procbarbeiro,0);
	printf ("Barbeiro activo \n");
	for (int i=1; i < MAX_CLIENTES; i++){
	    pthread_create(&t_cliente[i],0, Proccliente, i);
	    printf ("criou o cliente numero %d \n",i);
	    sleep(2);
	};
	/* Espera pela terminação dos clientes */
	for (int i=1;i < MAX_CLIENTES; i++){
	    pthread_join(t_cliente[i], &resul);
	    printf ("O cliente # %d resultado", i);
	    printf ((resul==0) ? " cortou cabelo \n" : " não cortou \n");
	}	
}
```









