
Vamos utilizar um exemplo:

```sql
pig(_id_,name,DOB,job)

nonpig(_id_,name,DOB,species)  
RI-1: id cannot be in pig  
RI-2: species must be ‘chicken’,‘cow’,‘goat’ or ‘sheep’

Produce(_code_,producer,date,amount,type)  
	producer: FK(nonpig.id)  
	UNIQUE(producer,date)  
RI-3: type must be ‘eggs’ or ‘milk’

merchant(_SSN_)

buys(_SSN_,_code_,seller,price)  
	SSN: FK(merchant)  
	code: FK(produce)  
	seller: FK(pig.id)
```

- exercícios com este exemplo no pp14. É DE FACTO MESMO BOM

## Agregação Simples

Primeiramente recapitulando algumas funções existentes vistas anteriormente:

| Função                    | Descrição                                                   |
| ------------------------- | ----------------------------------------------------------- |
| **``COUNT(+) / COUNT(1)``**   | Número de linhas                                            |
| **``COUNT([DISTINCT] col)``** | Número de linhas com valores [distintos] não nulos de `col` |
| **``SUM([DISTINCT] col)``**   | Soma dos valores [distintos] não nulos de ``col``           |
| **``AVG([DISTINCT] col)``**   | Médio dos valores [distintos] não nulos de ``col``          |
| **``MAX(col)``**              | O valor máximo entre os valores não nulos de ``col``        |
| **``MIN(col)``**              | O valor mínimo entre os valores não nulos de ``col``	                                                            |

- Podemos indicar as colunas pelas quais agrupamos valores usando **``GROUP BY``**.

```sql
-- Imaginemos que queremos saber a quantidade de compras feitas,
-- tanto no total como por cliente.

--   client |  price
-- ---------+-----------
--    Diogo |    20
--    José  |    15
--    Diogo |    18
--    Tiago |    12

-- Sem GROUP BY:
SELECT COUNT(*) as count FROM purchase;

--   count
-- --------
--     4
-- (1 row)

-- Com GROUP BY:
SELECT client, COUNT(*) as count FROM purchase
  GROUP BY client;

--   client |  count
-- ---------+---------
--    Diogo |    2
--    José  |    1
--    Tiago |    1
-- (3 rows)
```

- Caso queiramos filtrar linhas por uma condição que contém valores agrupados, rapidamente reparamos que tal não é possível com a cláusula `WHERE`: esta cláusula é executada **antes** da agregação. Para resolver este problema, temos de usar a cláusula `HAVING`, que funciona de forma semelhante ao `WHERE`, mas é executada **após** a agregação.

```sql
-- Pegando no exemplo anterior,
-- vamos agora querer os clientes com mais do que 1 compra.

SELECT client, COUNT(*) FROM frigu
  GROUP BY client
  HAVING COUNT(*) > 1;

--   client |  count
-- ---------+---------
--    Diogo |    2
-- (1 row)
```

- O output do **``GROUP BY``** é sempre uma linha por cada instância do grupo.
- É necessário quando se retorna colunas agregadas e não agregadas.
- Pode agrupar-se por várias colunas (separadas por vírgulas)
- Não faz sentido agrupar por chaves candidatas, não haverá agregação.

- O **``HAVING``** é semelhante ao `WHERE` mas a **seleção é feita após a agregação**.
- Podemos ter ``WHERE`` e **``HAVING``** na mesma query se quisermos filtrar linhas antes e após a agregação.

## Selects Encadeados

- Um ``SELECT`` de um ``SELECT`` pode ser usado:
	- Com **``FROM``** para fazer queries que requerem computação de tabelas.
	- Com **``WHERE ou HAVING``** para filtrar linhas antes ou após a agregação por compação de conjuntos.

#### Exemplos de usos do SELECT

###### INTERSECT
```sql
-- Quais os nomes dos porcos que também são nomes de vacas?

SELECT name FROM pig
	INTERSECT
SELECT name FROM nonpig WHERE species='cow';

-- ou

SELECT DISTINCT name  
FROM pig INNER JOIN nonpig USING (name)  
WHERE species=‘cow’;
```

###### UNION
```sql
-- Quais os nomes de todos os animais?

SELECT name FROM pig
	UNION
SELECT name FROM nonpig;

-- ou

SELECT DISTINCT name FROM pig FULL JOIN nonpig USING (name);
```

###### EXCEPT/DIFERENÇA
```sql
-- Quais os nomes dos porcos que não são nomes de cabras?

SELECT name FROM pig  
	EXCEPT  
SELECT name FROM nonpig WHERE species=‘goat’;
```

###### SELECTS Encadeados (dúvida?)
```sql
-- Mesmo exemplo de cima mas com SELECTS encadeados.

SELECT name  
FROM pig LEFT JOIN  
	(SELECT name FROM nonpig WHERE species=‘goat’) AS k USING (name)  
WHERE  
	k.species IS NULL;
```

```sql
-- Qual o volume máximo de vendas de entre todos os porcos?

SELECT MAX(total)  
FROM  
	(SELECT SUM(price) AS total FROM buys GROUP BY seller) AS k;
```

```sql
-- Qual o volume de vendas de cada porco cujo nome é partilhado por vacas  mas não por cabras?

SELECT seller, SUM(price)  
FROM buys NATURAL JOIN (  
	SELECT p.id AS seller FROM pig p JOIN nonpig USING (name)  
		WHERE species = ‘cow’ EXCEPT  
	SELECT p.id AS seller FROM pig p JOIN nonpig USING (name)  
		WHERE species = ‘goat’  
) AS k  
GROUP BY seller;
```


## Atribuição

- Isto permite simplificar queries com selects endadeados.  Esta cláusula pré-computa e declara-os à partida

```sql
-- Qual o porco que realizou a venda mais cara?

WITH comparison AS (  
	SELECT s1.seller AS expensive, s2.seller AS cheap  
	FROM seller s1, seller s2 WHERE s1.price > s2.price  
)  
SELECT expensive AS seller FROM comparison EXCEPT  
SELECT cheap AS seller FROM comparison;
```

Agora a seguir vamos ver o uso de alguns operadores de comparação.
Desde já podemos relacionar:

- **IN**(array) ⇔ = **ANY**(array)
- **NOT IN**(array) ⇔ **!= ALL**(array)

###### IN
```sql
-- Qual o volume de vendas de cada porco cujo nome é partilhado por  vacas mas não por cabras?

SELECT seller,SUM(price) FROM buys  
WHERE seller IN (  
	SELECT p.id FROM pig p JOIN nonpig USING (name) WHERE species = ‘cow’  
)  
AND seller NOT IN (  
	SELECT p.id FROM pig p JOIN nonpig USING (name) WHERE species = ‘goat’  
)  
GROUP BY seller;
```

###### ALL
```sql
-- Qual o porco que realizou a venda mais cara?

SELECT seller  
FROM buys  
WHERE price >= ALL(  
	SELECT price  
	FROM buys  
);

-- Qual o porco que tem o maior volume de vendas?

SELECT seller  
FROM buys  
GROUP BY seller HAVING SUM(price) >= ALL (  
	SELECT SUM(price) FROM buys GROUP BY seller  
);
```

###### EXISTS
- Operador que verifica se uma subquery retorna um conjunto não vazio.
```sql
-- Qual o volume de vendas de cada porco cujo nome é partilhado por  vacas mas não por cabras?

SELECT seller,SUM(price) FROM buys JOIN pig p ON (seller=id) WHERE EXISTS(  
	SELECT * FROM nonpig n WHERE p.name = n.name AND species = ‘cow’)  
AND NOT EXISTS(  
	SELECT * FROM nonpig n WHERE p.name = n.name AND species = ‘goat’)  
GROUP BY seller;
```

## Null

> [!TIP] Comportamento Normal
> Por norma quando criamos uma tabela os valores das colunas são null, para evitar isso:
> ```sql
CREATE TABLE student (
  ist_id VARCHAR(15) NOT NULL,
  student_name VARCHAR(255) NOT NULL,
  PRIMARY KEY(ist_id)
);

### Comportamentos do NULL

| Expressão          | Resultado |
| ------------------ | --------- |
| `5 + NULL`         | `NULL`    |
| ``NULL * 10``      | ``NULL``  |
| ``NULL AND TRUE``  | ``NULL``  |
| ``NULL AND FALSE`` | ``FALSE`` |
| ``NULL OR TRUE``   | ``TRUE``  |
| ``NULL OR FALSE``  | ``NULL``  |

#### Uso do IS em vez de =

```sql
-- O operador = não funciona:
SELECT * FROM student WHERE birthday = NULL;

--  ist_id | student_name | birthday
-- --------+--------------+----------
-- (0 rows)
```

```sql
-- O operador IS já funciona:
SELECT * FROM student WHERE birthday IS NULL;

--    ist_id   | student_name | birthday
-- ------------+--------------+----------
--  ist1123456 | Diogo        |
-- (1 row)
```

Podemos substituir os valores ``NULL`` com valores predefinidos como:

```sql
SELECT ist_id, COALESCE(grade, 0) AS grade FROM grades
  WHERE course = 'BD';

--    ist_id   | grade
-- ------------+-------
--  ist1123456 |    20
--  ist1654321 |     0
--  ist1123123 |    18
-- (3 rows)
```


# Resumo

```sql
-- Sem GROUP BY: agrega toda a tabela
SELECT COUNT(DISTINCT producer) FROM produce;

-- Com GROUP BY: agrega a tabela para cada valor das colunas no GROUP BY
SELECT seller, SUM(price) AS total FROM buys GROUP BY seller;

-- HAVING: seleção após a agregação
SELECT seller, SUM(price) AS total FROM buys GROUP BY seller HAVING total>1000;
```

A Agregação com Agrupamento pode:

- **``GROUP BY``** é obrigatório quando se retorna colunas agregadas e não  
agregadas, mas pode ser usado quando se retorna apenas uma das duas  
- Deve-se quase sempre retornar a(s) coluna(s) usada(s) para agrupar, ou os  
resultados não farão sentido  
- Pode retornar-se mais colunas, não usadas para agrupar, mas devem ser  
funcionalmente dependentes das colunas a agrupar  
- **``HAVING``** tem de ser sempre precedido por GROUP BY  
- Permite fazer agregação sem retornar o agregado

![[Pasted image 20230604153718.png]]

![[Pasted image 20230604153729.png]]

### Opções para Interseção

```sql
-- QUE NOMES SÃO PARTILHADOS POR PORCOS E NÃO PORCOS?

SELECT name FROM pig INTERSECT SELECT name FROM nonpig;
-- (Eficiente mas requer colunas compatíveis)

SELECT DISTINCT name FROM pig INNER JOIN nonpig USING (name);
-- (Quase sempre boa opção; única que permite devolver colunas de duas tabelas)

SELECT DISTINCT name FROM pig WHERE name IN (SELECT name FROM nonpig);
-- (Eficiente quando só queremos filtrar uma coluna)

SELECT DISTINCT name FROM pig p WHERE EXISTS
	(SELECT name FROM nonpig n WHERE n.name=p.name);
-- (Menos eficiente mas mais versátil para filtros complexos)
```

### Opções para Diferença

```sql
-- QUE PORCOS NÃO PARTICIPAM EM VENDAS?

SELECT id FROM pig EXCEPT SELECT seller FROM buys;
-- (Eficiente mas requer colunas compatíveis)

SELECT id FROM pig LEFT JOIN buys ON (id=seller) WHERE code IS NULL;
-- (Eficiente em casos em que não queremos filtrar a tabela da direita; mais complexa noutros casos)

SELECT id FROM pig WHERE id NOT IN (SELECT seller FROM buys);
-- (Eficiente quando só queremos filtrar uma coluna)

SELECT id FROM pig WHERE NOT EXISTS
	(SELECT seller FROM buys WHERE seller=id);
-- (Menos eficiente mas mais versátil para filtros complexos)
```

## Determinação do Elemento Distintivo

```sql
-- QUAL ESPÉCIE DE ANIMAL MAIS PRODUTIVA?
    GROUP BY species           SUM(amount)

SELECT species                                -- Retornador agrupador.
FROM produce JOIN nonpig ON (producer=id)     -- Ligar agrupador ao agregado.
GROUP BY species HAVING SUM(amount) >= ALL (  -- agrupar, agregar e comparar.
	SELECT SUM(amount)                        
	FROM produce JOIN nonpig ON (producer=id) -- equivalente mas retorna
	GROUP BY species                          -- agregado.
);
```


